# -*- coding: utf-8 -*-
"""House Price Prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QYbTP20CSzBC1wv9WNnXRFkwTIOlBns6

Project: House Price Prediction

This script demonstrates a complete data science workflow for a portfolio project.
It covers Data Preparation, Exploratory Data Analysis (EDA), Model Building,
and Results Visualization.
"""

from google.colab import files
uploaded = files.upload()

# SECTION 0: IMPORT LIBRARIES

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.linear_model import LinearRegression
from sklearn.tree import DecisionTreeRegressor
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import r2_score, mean_squared_error

# Set plot style for better visuals
sns.set_style('whitegrid')
plt.rc('figure', figsize=(12, 8))

# SECTION 1: DATA PREPARATION
print("--- Section 1: Data Preparation ---")

# 1.1: Load the CSV with pandas
df = pd.read_csv('train.csv')
print(f"Dataset shape: {df.shape}")

# 1.2: Handle Missing Values
numerical_cols = df.select_dtypes(include=np.number).columns
categorical_cols = df.select_dtypes(include=['object']).columns

# For numerical columns, impute with the median.
for col in numerical_cols:
    df[col].fillna(df[col].median(), inplace=True)

# For categorical columns, impute with the most frequent value (mode).
for col in categorical_cols:
    df[col].fillna(df[col].mode()[0], inplace=True)

print("Missing values handled.")

# 1.3: Encode Categorical Features
df = pd.get_dummies(df, columns=categorical_cols, drop_first=True)
print("Categorical features encoded.")
print(f"Dataset shape after encoding: {df.shape}")


# 1.4: Define Features (X) and Target (y)
X = df.drop('SalePrice', axis=1)
y = df['SalePrice']

# Log transform the target variable 'SalePrice' to handle its skewness.
y_log = np.log1p(y)

# 1.5: Split into Train/Test Sets
X_train, X_test, y_train, y_test = train_test_split(X, y_log, test_size=0.2, random_state=42)
print("Data split into training and testing sets.")
print(f"Training set size: {len(X_train)}")
print(f"Testing set size: {len(X_test)}")

# SECTION 2: EXPLORATORY DATA ANALYSIS (EDA)
print("\n--- Section 2: Exploratory Data Analysis (EDA) ---")

# 2.1: Show Price Distribution
plt.figure(figsize=(10, 6))
sns.histplot(df['SalePrice'], kde=True, bins=50)
plt.title('Distribution of House Sale Prices')
plt.xlabel('Sale Price (in USD)')
plt.ylabel('Frequency')
plt.savefig('eda_price_distribution.png')
print("EDA Plot 1: 'eda_price_distribution.png' saved.")

# 2.2: Plot Correlations
correlation_matrix = df.corr()
top_n = 15 # number of features to show
top_corr_features = correlation_matrix.nlargest(top_n, 'SalePrice')['SalePrice'].index
top_corr_matrix = df[top_corr_features].corr()

plt.figure(figsize=(12, 10))
sns.heatmap(top_corr_matrix, annot=True, cmap='coolwarm', fmt='.2f')
plt.title(f'Top {top_n} Features Correlated with Sale Price')
plt.savefig('eda_correlation_heatmap.png')
print("EDA Plot 2: 'eda_correlation_heatmap.png' saved.")

# 2.3: Use Scatter Plots
plt.figure(figsize=(10, 6))
sns.scatterplot(x=df['GrLivArea'], y=df['SalePrice'])
plt.title('Living Area vs. Sale Price')
plt.xlabel('Above Grade Living Area (sq. ft.)')
plt.ylabel('Sale Price (in USD)')
plt.savefig('eda_area_vs_price.png')
print("EDA Plot 3: 'eda_area_vs_price.png' saved.")

# SECTION 3: MODEL BUILDING & EVALUATION
print("\n--- Section 3: Model Building & Evaluation ---")

models = {
    'Linear Regression': LinearRegression(),
    'Decision Tree': DecisionTreeRegressor(random_state=42),
    'Random Forest': RandomForestRegressor(random_state=42)
}

results = {}
predictions = {} # Dictionary to store predictions for plotting

for name, model in models.items():
    # Train the model
    model.fit(X_train, y_train)

    # Make predictions on the test set
    y_pred = model.predict(X_test)

    # transform the predictions back from log scale to the original scale
    y_test_orig = np.expm1(y_test)
    y_pred_orig = np.expm1(y_pred)

    # Store results and predictions
    results[name] = {'R²': r2_score(y_test_orig, y_pred_orig),
                     'RMSE': np.sqrt(mean_squared_error(y_test_orig, y_pred_orig))}
    predictions[name] = y_pred_orig # Store original scale predictions

    print(f"Model: {name}")
    print(f"  R² Score: {results[name]['R²']:.4f}")
    print(f"  RMSE: ${results[name]['RMSE']:,.2f}\n")

# Create a DataFrame for easy comparison
results_df = pd.DataFrame(results).T

# SECTION 4: FINAL RESULTS & VISUALIZATION
print("\n--- Section 4: Final Results & Visualization ---")

print("\nFinal Model Performance Comparison:")
print(results_df.sort_values(by='RMSE', ascending=True))

# Identify the best model based on the lowest RMSE
best_model_name = results_df['RMSE'].idxmin()
best_model_rmse = results_df['RMSE'].min()
print(f"\nBest performing model: {best_model_name} with an RMSE of ${best_model_rmse:,.2f}")

# 4.1: Plot model comparison
plt.figure(figsize=(8, 5)) # Reduced figure size
results_df['RMSE'].sort_values(ascending=False).plot(kind='barh', color='skyblue')
plt.title('Model Comparison by Root Mean Squared Error (RMSE)')
plt.xlabel('RMSE (Lower is better)')
plt.tight_layout() # Adjusts plot to ensure everything fits without overlapping
plt.savefig('results_model_comparison.png')
print("\nResults Plot 1: 'results_model_comparison.png' saved.")

# 4.2: Plot predictions vs. actuals for the best model
# Get the predictions for the best performing model
y_pred_best_orig = predictions[best_model_name]

plt.figure(figsize=(8, 5))
sns.scatterplot(x=y_test_orig, y=y_pred_best_orig, alpha=0.6)
plt.plot([y_test_orig.min(), y_test_orig.max()], [y_test_orig.min(), y_test_orig.max()],
         '--r', linewidth=2)
plt.title(f'{best_model_name}: Actual vs. Predicted Prices')
plt.xlabel('Actual Sale Price')
plt.ylabel('Predicted Sale Price')
plt.tight_layout()
plt.savefig('results_actual_vs_predicted.png')
print("Results Plot 2: 'results_actual_vs_predicted.png' saved.")
plt.show()

print("\n--- Project Complete ---")